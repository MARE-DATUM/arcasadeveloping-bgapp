<!DOCTYPE html>
<html lang="pt">
<head>
    <!-- Favicon BGAPP -->
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <meta name="theme-color" content="#173c72">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BGAPP ML Demo - deck.gl WebGL2 DEFINITIVO</title>
    
    <!-- CSS Libraries -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    
    <!-- deck.gl ONLY - NO LEAFLET -->
    <script src="https://unpkg.com/deck.gl@9.1.14/dist.min.js"></script>
    
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #000000 !important;
        }
        
        * {
            color: #000000 !important;
        }
        
        .text-white, .navbar-brand, .nav-link {
            color: #ffffff !important;
        }
        
        .demo-header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 2rem 0;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        
        .demo-container {
            padding: 2rem 0;
        }
        
        .demo-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .demo-map {
            height: 600px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 2px solid #00d4ff;
            position: relative;
            background: #001122;
        }
        
        .demo-controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }
        
        .btn-demo {
            background: linear-gradient(135deg, #6f42c1, #17a2b8);
            border: none;
            color: white !important;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .btn-demo:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(111, 66, 193, 0.3);
            color: white !important;
        }
        
        .btn-demo.active {
            background: linear-gradient(135deg, #00d4ff, #00ffaa);
        }
        
        .deck-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1001;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .deck-btn {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.9), rgba(111, 66, 193, 0.9));
            border: 1px solid rgba(0, 212, 255, 0.5);
            color: white !important;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s ease;
        }
        
        .deck-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.4);
        }
        
        .demo-log {
            background: #1a1a1a;
            color: #00ff00 !important;
            padding: 1rem;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 1rem;
        }
        
        .demo-log div {
            color: #00ff00 !important;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="demo-header">
        <div class="container">
            <div class="row align-items-center">
                <div class="col-md-8">
                    <h1 class="h2 mb-2">üéÆ BGAPP ML Demo - deck.gl WebGL2 DEFINITIVO</h1>
                    <p class="lead mb-0">Mapa deck.gl com delimita√ß√µes oficiais de Angola + Visualiza√ß√µes Unreal Engine</p>
                </div>
                <div class="col-md-4 text-md-end">
                    <span class="status-badge" style="background: #00d4ff; color: white; padding: 0.5rem 1rem; border-radius: 20px;">deck.gl WebGL2</span>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container demo-container">
        
        <!-- deck.gl Map -->
        <div class="demo-section">
            <h3>üåê Mapa deck.gl com Delimita√ß√µes Oficiais de Angola</h3>
            <p>Mapa WebGL2 com ZEE oficial, esta√ß√µes Copernicus reais e visualiza√ß√µes Unreal Engine.</p>
            
            <!-- Controls -->
            <div class="demo-controls">
                <button class="btn btn-demo" onclick="confirmDeckGL()">
                    üîç Confirmar deck.gl
                </button>
                <button class="btn btn-demo" onclick="debugZEELayers()">
                    üîç Debug ZEE
                </button>
                <button class="btn btn-demo" onclick="createAnimatedHeatmap()">
                    üî• Heatmap Animado
                </button>
                <button class="btn btn-demo" onclick="createSpeciesEmojis()">
                    üêü Esp√©cies Emojis
                </button>
                <button class="btn btn-demo" onclick="createMigrationRoutes()">
                    üêã Rotas Migra√ß√£o
                </button>
                <button class="btn btn-demo" onclick="createRiskZones()">
                    ‚ö†Ô∏è Zonas de Risco
                </button>
                <button class="btn btn-demo" onclick="createAllVisualizations()">
                    üé® Todas Visualiza√ß√µes
                </button>
                <button class="btn btn-demo" onclick="clearAllLayers()">
                    üßπ Limpar Tudo
                </button>
            </div>
            
            <!-- Background Controls -->
            <div class="demo-controls">
                <h6 style="width: 100%; margin-bottom: 0.5rem; color: #17a2b8;">üó∫Ô∏è Background Layers:</h6>
                <button class="btn btn-demo active" onclick="switchBackground('openstreetmap')">
                    üó∫Ô∏è OpenStreetMap
                </button>
                <button class="btn btn-demo" onclick="switchBackground('esri-satellite')">
                    üì° ESRI Satellite
                </button>
                <button class="btn btn-demo" onclick="switchBackground('carto-light')">
                    ‚òÄÔ∏è Carto Light
                </button>
            </div>
            
            <div id="deckgl-map" class="demo-map">
                <!-- deck.gl controls -->
                <div class="deck-controls">
                    <button class="deck-btn" onclick="resetView()" title="Reset View">
                        üéØ Reset
                    </button>
                    <button class="deck-btn" onclick="takeScreenshot()" title="Screenshot">
                        üì∏ Print
                    </button>
                    <button class="deck-btn" onclick="toggleFullscreen()" title="Fullscreen">
                        ‚õ∂ Full
                    </button>
                </div>
            </div>
            
            <h5 class="mt-4">Log deck.gl</h5>
            <div id="deckgl-log" class="demo-log">
                <div>üöÄ Inicializando deck.gl ML Demo DEFINITIVO...</div>
            </div>
        </div>
    </div>

    <script>
        // DECK.GL ONLY - NO LEAFLET FALLBACK
        class DeckGLMLDemoFinal {
            constructor() {
                this.deck = null;
                this.layers = [];
                this.backgroundLayers = {};
                this.currentBackground = null;
                this.logContainer = document.getElementById('deckgl-log');
                this.animationId = null;
                this.time = 0;
                
                this.init();
            }
            
            async init() {
                this.log('üöÄ Inicializando deck.gl DEFINITIVO...');
                
                try {
                    await this.waitForDeckGL();
                    this.createDeckGLMap();
                    this.createBackgroundLayers();
                    this.createOfficialAngolaLayers();
                    this.startAnimationLoop();
                    
                    this.log('‚úÖ deck.gl ML Demo DEFINITIVO inicializado!');
                    this.log('üîç Framework confirmado: deck.gl WebGL2');
                    
                } catch (error) {
                    this.log(`‚ùå ERRO CR√çTICO: ${error.message}`);
                }
            }
            
            async waitForDeckGL() {
                this.log('‚è≥ Aguardando deck.gl...');
                
                return new Promise((resolve, reject) => {
                    let attempts = 0;
                    const maxAttempts = 50;
                    
                    const check = () => {
                        attempts++;
                        if (typeof deck !== 'undefined' && deck.DeckGL) {
                            this.log(`‚úÖ deck.gl encontrado (tentativa ${attempts})`);
                            resolve();
                        } else if (attempts >= maxAttempts) {
                            reject(new Error('deck.gl n√£o carregou'));
                        } else {
                            setTimeout(check, 100);
                        }
                    };
                    check();
                });
            }
            
            createDeckGLMap() {
                this.log('üåê Criando mapa deck.gl...');
                
                this.deck = new deck.DeckGL({
                    container: 'deckgl-map',
                    initialViewState: {
                        longitude: 13.5,
                        latitude: -12.5,
                        zoom: 6,
                        pitch: 0,
                        bearing: 0
                    },
                    controller: true,
                    layers: [],
                    onClick: (info) => {
                        if (info.object) {
                            this.handleClick(info.object, info.layer);
                        }
                    },
                    onHover: (info) => {
                        const container = document.getElementById('deckgl-map');
                        container.style.cursor = info.object ? 'pointer' : 'default';
                    },
                    getTooltip: ({object, layer}) => {
                        if (!object) return null;
                        return this.getTooltipContent(object, layer);
                    }
                });
                
                this.log('‚úÖ deck.gl map criado');
            }
            
            createBackgroundLayers() {
                this.log('üé® Criando background layers...');
                
                this.backgroundLayers = {
                    'openstreetmap': new deck.TileLayer({
                        id: 'openstreetmap',
                        data: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
                        minZoom: 0,
                        maxZoom: 18,
                        tileSize: 256,
                        renderSubLayers: props => {
                            const {bbox: {west, south, east, north}} = props.tile;
                            return new deck.BitmapLayer(props, {
                                data: null,
                                image: props.data,
                                bounds: [west, south, east, north]
                            });
                        }
                    }),
                    
                    'esri-satellite': new deck.TileLayer({
                        id: 'esri-satellite',
                        data: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                        minZoom: 0,
                        maxZoom: 17,
                        tileSize: 256,
                        renderSubLayers: props => {
                            const {bbox: {west, south, east, north}} = props.tile;
                            return new deck.BitmapLayer(props, {
                                data: null,
                                image: props.data,
                                bounds: [west, south, east, north]
                            });
                        }
                    }),
                    
                    'carto-light': new deck.TileLayer({
                        id: 'carto-light',
                        data: 'https://cartodb-basemaps-a.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png',
                        minZoom: 0,
                        maxZoom: 18,
                        tileSize: 256,
                        renderSubLayers: props => {
                            const {bbox: {west, south, east, north}} = props.tile;
                            return new deck.BitmapLayer(props, {
                                data: null,
                                image: props.data,
                                bounds: [west, south, east, north]
                            });
                        }
                    })
                };
                
                this.currentBackground = this.backgroundLayers['openstreetmap'];
                this.log(`‚úÖ ${Object.keys(this.backgroundLayers).length} background layers criadas`);
            }
            
            async createOfficialAngolaLayers() {
                this.log('üá¶üá¥ Criando ZEE baseada na LINHA COSTEIRA real...');
                
                try {
                    // Load detailed coastline data
                    const coastlineData = await this.loadAngolaCoastlineData();
                    
                    if (coastlineData) {
                        this.createZEEFromCoastline(coastlineData);
                    } else {
                        this.createRealtimeAngolaZEE();
                    }
                } catch (error) {
                    this.log(`‚ùå Erro coastline: ${error.message}`);
                    this.createRealtimeAngolaZEE();
                }
            }
            
            async loadAngolaCoastlineData() {
                this.log('üì° Carregando linha costeira detalhada de Angola...');
                
                try {
                    const response = await fetch('assets/data/angola-coastline-detailed.json');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const data = await response.json();
                    this.log('‚úÖ Linha costeira detalhada carregada');
                    return data;
                    
                } catch (error) {
                    this.log(`‚ö†Ô∏è Coastline indispon√≠vel: ${error.message}`);
                    return null;
                }
            }
            
            createZEEFromCoastline(coastlineData) {
                this.log('üåä Criando ZEE baseada na linha costeira REAL...');
                
                const angolaCoastline = coastlineData.features.find(f => f.properties.name.includes('Angola Coastline'));
                const cabindaCoastline = coastlineData.features.find(f => f.properties.name.includes('Cabinda Coastline'));
                
                // 1. Show actual coastline first
                const coastlineLayer = new deck.GeoJsonLayer({
                    id: 'angola-coastline',
                    data: angolaCoastline,
                    pickable: false,
                    stroked: true,
                    filled: false,
                    lineWidthScale: 1,
                    lineWidthMinPixels: 2,
                    getLineColor: [255, 215, 0, 255], // Gold coastline
                    getLineWidth: 2
                });
                
                // 2. Create ZEE as offset from coastline
                const angolaZEEFromCoast = this.createZEEOffset(angolaCoastline.geometry.coordinates, 200); // 200nm
                const cabindaZEEFromCoast = this.createZEEOffset(cabindaCoastline.geometry.coordinates, 200);
                
                const angolaZEE = new deck.SolidPolygonLayer({
                    id: 'zee-angola-coastline',
                    data: [{
                        polygon: angolaZEEFromCoast
                    }],
                    filled: true,
                    stroked: true,
                    getFillColor: [0, 128, 255, 150],
                    getLineColor: [0, 102, 204, 255],
                    lineWidthMinPixels: 4,
                    pickable: true
                });
                
                const cabindaZEE = new deck.SolidPolygonLayer({
                    id: 'zee-cabinda-coastline',
                    data: [{
                        polygon: cabindaZEEFromCoast
                    }],
                    filled: true,
                    stroked: true,
                    getFillColor: [155, 89, 182, 150],
                    getLineColor: [155, 89, 182, 255],
                    lineWidthMinPixels: 4,
                    pickable: true
                });
                
                // Esta√ß√µes Copernicus
                const stationLayer = new deck.ScatterplotLayer({
                    id: 'copernicus-coastline',
                    data: this.getCopernicusData(),
                    pickable: true,
                    opacity: 1.0,
                    stroked: true,
                    filled: true,
                    radiusScale: 1,
                    radiusMinPixels: 12,
                    radiusMaxPixels: 20,
                    getPosition: d => [d.longitude, d.latitude],
                    getRadius: d => d.type === 'upwelling_station' ? 18 : 14,
                    getFillColor: d => this.getStationColor(d.type),
                    getLineColor: [255, 255, 255, 255],
                    lineWidthMinPixels: 3
                });
                
                // Set layers
                this.setLayers([
                    this.currentBackground,
                    coastlineLayer,      // Linha costeira dourada
                    angolaZEE,          // ZEE baseada na costa
                    cabindaZEE,         // ZEE Cabinda baseada na costa
                    stationLayer        // Esta√ß√µes
                ]);
                
                this.baseLayers = [coastlineLayer, angolaZEE, cabindaZEE, stationLayer];
                
                this.log('‚úÖ ZEE criada baseada na LINHA COSTEIRA real!');
                this.log('üåä ZEE segue a costa de Angola precisamente');
                this.log('üü° Linha costeira dourada vis√≠vel');
            }
            
            createZEEOffset(coastlineCoords, offsetNM) {
                // Create ZEE as 200nm offset from coastline
                // Simplified approach: create envelope around coastline
                
                const offsetDegrees = offsetNM * 0.0167; // Aproxima√ß√£o: 1nm ‚âà 0.0167¬∞
                
                const zeeCoords = [];
                
                // Create outer boundary (offshore)
                coastlineCoords.forEach(coord => {
                    zeeCoords.push([coord[0] - offsetDegrees, coord[1]]); // West offset
                });
                
                // Add coastline points (reversed for proper polygon)
                for (let i = coastlineCoords.length - 1; i >= 0; i--) {
                    zeeCoords.push(coastlineCoords[i]);
                }
                
                // Close polygon
                zeeCoords.push(zeeCoords[0]);
                
                return zeeCoords;
            }
            
            async loadEOXCoastlineData() {
                this.log('üì° Carregando dados EOX Coastline...');
                
                try {
                    const response = await fetch('assets/data/eox-angola-coastline.json');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const data = await response.json();
                    this.log('‚úÖ Dados EOX Coastline carregados');
                    return data;
                    
                } catch (error) {
                    this.log(`‚ö†Ô∏è EOX Coastline indispon√≠vel: ${error.message}`);
                    return null;
                }
            }
            
            createEOXZEELayers(eoxData) {
                this.log('üåä Criando ZEE com dados EOX Coastline...');
                
                const features = eoxData.features;
                const angolaFeature = features.find(f => f.properties.name.includes('Angola EEZ'));
                const cabindaFeature = features.find(f => f.properties.name.includes('Cabinda EEZ'));
                
                // 1. ZEE Angola com coordenadas EOX
                const angolaZEE = new deck.GeoJsonLayer({
                    id: 'zee-angola-eox',
                    data: angolaFeature,
                    pickable: true,
                    stroked: true,
                    filled: true,
                    lineWidthScale: 1,
                    lineWidthMinPixels: 4,
                    getFillColor: [0, 150, 255, 100],    // Blue fill
                    getLineColor: [0, 102, 204, 255],    // Blue border
                    getLineWidth: 4
                });
                
                // 2. ZEE Cabinda com coordenadas EOX  
                const cabindaZEE = new deck.GeoJsonLayer({
                    id: 'zee-cabinda-eox',
                    data: cabindaFeature,
                    pickable: true,
                    stroked: true,
                    filled: true,
                    lineWidthScale: 1,
                    lineWidthMinPixels: 4,
                    getFillColor: [155, 89, 182, 100],   // Purple fill
                    getLineColor: [155, 89, 182, 255],   // Purple border
                    getLineWidth: 4
                });
                
                // 3. Esta√ß√µes Copernicus
                const copernicusStations = new deck.ScatterplotLayer({
                    id: 'copernicus-stations',
                    data: this.getCopernicusData(),
                    pickable: true,
                    opacity: 1.0,
                    stroked: true,
                    filled: true,
                    radiusScale: 1,
                    radiusMinPixels: 12,
                    radiusMaxPixels: 20,
                    getPosition: d => [d.longitude, d.latitude],
                    getRadius: d => d.type === 'upwelling_station' ? 18 : 14,
                    getFillColor: d => this.getStationColor(d.type),
                    getLineColor: [255, 255, 255, 255],
                    lineWidthMinPixels: 3
                });
                
                // Set layers with EOX data
                this.setLayers([
                    this.currentBackground,
                    angolaZEE,           // ZEE Angola EOX
                    cabindaZEE,          // ZEE Cabinda EOX
                    copernicusStations   // Esta√ß√µes
                ]);
                
                this.baseLayers = [angolaZEE, cabindaZEE, copernicusStations];
                
                this.log('‚úÖ ZEE criada com dados EOX Coastline!');
                this.log('üåä Delimita√ß√µes de alta precis√£o EOX');
                this.log('üìä GeoJsonLayer para m√°xima qualidade');
            }
            
            createRealtimeAngolaZEE() {
                this.log('üéØ Criando ZEE com coordenadas EXATAS do realtime_angola.html...');
                
                // ZEE Angola Continental - COORDENADAS EXATAS (linha 1119-1124 do realtime_angola.html)
                const angolaZEECoords = [
                    [-6.02, 12.35], [-8.0, 12.48], [-10.5, 12.78], [-12.28, 12.98], 
                    [-14.5, 13.22], [-16.0, 13.18], [-17.266, 13.35], // PARA no Rio Cunene
                    [-17.266, 10.05], [-16.0, 9.88], [-14.5, 9.92], [-12.28, 9.68],
                    [-10.5, 9.48], [-8.0, 9.18], [-6.02, 9.05], [-6.02, 12.35] // Inicia AP√ìS gap da RDC
                ];
                
                // ZEE Cabinda - COORDENADAS EXATAS (linha 1127-1129 do realtime_angola.html)
                const cabindaZEECoords = [
                    [-4.26, 12.23], [-4.26, 11.45], [-5.56, 11.45], [-5.56, 12.23], [-4.26, 12.23]
                ];
                
                // Converter Leaflet [lat, lon] ‚Üí deck.gl [lon, lat]
                const angolaZEEDeckGL = angolaZEECoords.map(coord => [coord[1], coord[0]]);
                const cabindaZEEDeckGL = cabindaZEECoords.map(coord => [coord[1], coord[0]]);
                
                // ZEE Angola com configura√ß√µes EXATAS do realtime_angola.html
                const angolaZEE = new deck.SolidPolygonLayer({
                    id: 'zee-angola-exact',
                    data: [{
                        polygon: angolaZEEDeckGL,
                        properties: {
                            name: 'ZEE Angola Continental',
                            area: '495.866 km¬≤',
                            source: 'Marine Regions (eez_v11)'
                        }
                    }],
                    filled: true,
                    stroked: true,
                    getFillColor: [0, 128, 255, 200],    // MUITO MAIS VIS√çVEL
                    getLineColor: [255, 0, 0, 255],      // Borda vermelha MUITO vis√≠vel
                    lineWidthMinPixels: 6,               // LINHA MUITO ESPESSA
                    pickable: true
                });
                
                // ZEE Cabinda com configura√ß√µes EXATAS do realtime_angola.html
                const cabindaZEE = new deck.SolidPolygonLayer({
                    id: 'zee-cabinda-exact',
                    data: [{
                        polygon: cabindaZEEDeckGL,
                        properties: {
                            name: 'ZEE Cabinda',
                            area: 'Prov√≠ncia separada',
                            source: 'Marine Regions (eez_v11)'
                        }
                    }],
                    filled: true,
                    stroked: true,
                    getFillColor: [255, 0, 255, 200],    // MAGENTA MUITO MAIS VIS√çVEL
                    getLineColor: [255, 0, 255, 255],    // Borda magenta MUITO vis√≠vel
                    lineWidthMinPixels: 6,               // LINHA MUITO ESPESSA
                    pickable: true
                });
                
                // 3. Esta√ß√µes Copernicus REAIS
                const copernicusStations = new deck.ScatterplotLayer({
                    id: 'copernicus-stations',
                    data: this.getCopernicusData(),
                    pickable: true,
                    opacity: 1.0,
                    stroked: true,
                    filled: true,
                    radiusScale: 1,
                    radiusMinPixels: 12,
                    radiusMaxPixels: 20,
                    getPosition: d => [d.longitude, d.latitude],
                    getRadius: d => d.type === 'upwelling_station' ? 18 : 14,
                    getFillColor: d => this.getStationColor(d.type),
                    getLineColor: [255, 255, 255, 255],
                    lineWidthMinPixels: 3
                });
                
                // Esta√ß√µes Copernicus (fallback)
                const copernicusStationsFallback = new deck.ScatterplotLayer({
                    id: 'copernicus-stations-fallback',
                    data: this.getCopernicusData(),
                    pickable: true,
                    opacity: 1.0,
                    stroked: true,
                    filled: true,
                    radiusScale: 1,
                    radiusMinPixels: 12,
                    radiusMaxPixels: 20,
                    getPosition: d => [d.longitude, d.latitude],
                    getRadius: d => d.type === 'upwelling_station' ? 18 : 14,
                    getFillColor: d => this.getStationColor(d.type),
                    getLineColor: [255, 255, 255, 255],
                    lineWidthMinPixels: 3
                });
                
                // Esta√ß√µes Copernicus (rename para evitar conflito)
                const stationLayer = new deck.ScatterplotLayer({
                    id: 'copernicus-exact',
                    data: this.getCopernicusData(),
                    pickable: true,
                    opacity: 1.0,
                    stroked: true,
                    filled: true,
                    radiusScale: 1,
                    radiusMinPixels: 12,
                    radiusMaxPixels: 20,
                    getPosition: d => [d.longitude, d.latitude],
                    getRadius: d => d.type === 'upwelling_station' ? 18 : 14,
                    getFillColor: d => this.getStationColor(d.type),
                    getLineColor: [255, 255, 255, 255],
                    lineWidthMinPixels: 3
                });
                
                // Set layers - ORDEM IMPORTANTE
                this.setLayers([
                    this.currentBackground,   // Background primeiro
                    angolaZEE,               // ZEE Angola (deve aparecer)
                    cabindaZEE,              // ZEE Cabinda (deve aparecer)
                    stationLayer             // Esta√ß√µes por cima
                ]);
                
                this.baseLayers = [angolaZEE, cabindaZEE, stationLayer];
                
                this.log('‚úÖ ZEE EXATA do realtime_angola.html criada!');
                this.log(`üîç Angola ZEE: ${angolaZEEDeckGL.length} pontos convertidos`);
                this.log(`üîç Cabinda ZEE: ${cabindaZEEDeckGL.length} pontos convertidos`);
                this.log('üéØ Configura√ß√µes id√™nticas ao realtime_angola.html');
                this.log('üåä fillOpacity: 0.08, opacity: 0.7 (valores originais)');
                
                // DEBUG: Log coordenadas para verifica√ß√£o
                this.log('üîç COORDENADAS ANGOLA ZEE:');
                this.log(`   Primeiro ponto: [${angolaZEEDeckGL[0][0]}, ${angolaZEEDeckGL[0][1]}]`);
                this.log(`   √öltimo ponto: [${angolaZEEDeckGL[angolaZEEDeckGL.length-1][0]}, ${angolaZEEDeckGL[angolaZEEDeckGL.length-1][1]}]`);
                this.log('üîç COORDENADAS CABINDA ZEE:');
                this.log(`   Primeiro ponto: [${cabindaZEEDeckGL[0][0]}, ${cabindaZEEDeckGL[0][1]}]`);
                this.log(`   √öltimo ponto: [${cabindaZEEDeckGL[cabindaZEEDeckGL.length-1][0]}, ${cabindaZEEDeckGL[cabindaZEEDeckGL.length-1][1]}]`);
                this.log('üö® ATEN√á√ÉO: ZEE com opacidade M√ÅXIMA para debug!');
                this.log('üî¥ Se n√£o v√™ √°reas AZUL e MAGENTA, h√° problema de renderiza√ß√£o!');
            }
            
            getCopernicusData() {
                return [
                    { 
                        latitude: -5.0, longitude: 12.0, 
                        temp: 28.1, chl: 0.96, salinity: 35.1,
                        type: 'copernicus_station', 
                        name: 'Cabinda Norte - Esta√ß√£o Copernicus',
                        conditions: '√Åguas tropicais - Baixa produtividade'
                    },
                    { 
                        latitude: -8.8, longitude: 13.2, 
                        temp: 24.4, chl: 3.25, salinity: 35.29,
                        type: 'copernicus_station', 
                        name: 'Luanda Central - Esta√ß√£o Copernicus',
                        conditions: 'Condi√ß√µes normais'
                    },
                    { 
                        latitude: -12.6, longitude: 13.4, 
                        temp: 17.6, chl: 30.24, salinity: 35.5,
                        type: 'upwelling_station', 
                        name: 'Benguela - Zona de Upwelling Copernicus',
                        conditions: 'Upwelling ativo - Alta produtividade'
                    },
                    { 
                        latitude: -15.2, longitude: 12.1, 
                        temp: 18.4, chl: 18.40, salinity: 35.53,
                        type: 'upwelling_station', 
                        name: 'Namibe Costeiro - Esta√ß√£o Copernicus',
                        conditions: 'Upwelling ativo - Alta produtividade'
                    },
                    { 
                        latitude: -16.8, longitude: 11.8, 
                        temp: 17.4, chl: 8.85, salinity: 35.54,
                        type: 'upwelling_station', 
                        name: 'Tombwa Profundo - Esta√ß√£o Copernicus',
                        conditions: 'Upwelling ativo - Alta produtividade'
                    }
                ];
            }
            
            getStationColor(type) {
                return type === 'upwelling_station' ? 
                    [0, 255, 136, 255] : // Green for upwelling
                    [0, 102, 204, 255];  // Blue for regular
            }
            
            getTooltipContent(object, layer) {
                if (layer.id === 'copernicus-stations') {
                    return {
                        html: `
                            <div style="
                                background: rgba(255, 255, 255, 0.98); 
                                color: #000000; 
                                padding: 16px; 
                                border-radius: 12px; 
                                font-size: 14px; 
                                max-width: 300px;
                                border: 3px solid #00d4ff;
                                box-shadow: 0 8px 32px rgba(0,0,0,0.7);
                                backdrop-filter: blur(15px);
                            ">
                                <div style="display: flex; align-items: center; margin-bottom: 12px;">
                                    <span style="font-size: 24px; margin-right: 12px;">üõ∞Ô∏è</span>
                                    <div>
                                        <strong style="font-size: 16px; color: #0066cc; text-shadow: none;">${object.name}</strong><br>
                                        <span style="font-size: 12px; color: #666; font-weight: 600;">${object.type === 'upwelling_station' ? 'Zona de Upwelling' : 'Esta√ß√£o Copernicus'}</span>
                                    </div>
                                </div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin: 12px 0;">
                                    <div style="text-align: center; background: #e3f2fd; padding: 10px; border-radius: 8px; border: 2px solid #2196f3;">
                                        <div style="font-size: 20px; font-weight: bold; color: #0d47a1;">${object.temp}¬∞C</div>
                                        <div style="font-size: 12px; color: #1565c0; font-weight: 600;">üå°Ô∏è Temperatura</div>
                                    </div>
                                    <div style="text-align: center; background: #e8f5e8; padding: 10px; border-radius: 8px; border: 2px solid #4caf50;">
                                        <div style="font-size: 20px; font-weight: bold; color: #1b5e20;">${object.chl}</div>
                                        <div style="font-size: 12px; color: #2e7d32; font-weight: 600;">üå± Chl-a mg/m¬≥</div>
                                    </div>
                                </div>
                                <div style="background: #f0f8ff; padding: 12px; border-radius: 8px; margin: 8px 0; border: 1px solid #90caf9;">
                                    <div style="font-size: 14px; color: #0d47a1; font-weight: bold;">üåä ${object.conditions}</div>
                                    <div style="font-size: 12px; color: #424242; margin-top: 6px; font-weight: 500;">
                                        üìç ${object.latitude.toFixed(4)}¬∞, ${object.longitude.toFixed(4)}¬∞<br>
                                        üßÇ Salinidade: ${object.salinity} PSU
                                    </div>
                                </div>
                            </div>
                        `
                    };
                }
                
                if (layer.id === 'migration-routes') {
                    return {
                        html: `
                            <div style="
                                background: rgba(255, 255, 255, 0.98); 
                                color: #000000; 
                                padding: 14px; 
                                border-radius: 10px; 
                                font-size: 13px; 
                                max-width: 250px;
                                border: 3px solid #4caf50;
                                box-shadow: 0 6px 24px rgba(0,0,0,0.6);
                            ">
                                <div style="display: flex; align-items: center; margin-bottom: 10px;">
                                    <span style="font-size: 20px; margin-right: 10px;">${this.getSpeciesEmoji(object.species)}</span>
                                    <strong style="font-size: 15px; color: #1b5e20; text-shadow: none;">${object.species}</strong>
                                </div>
                                <div style="background: #e8f5e8; padding: 10px; border-radius: 6px; border: 1px solid #4caf50;">
                                    <div style="font-size: 13px; color: #e65100; font-weight: bold;">üìÖ √âpoca: ${object.season}</div>
                                    <div style="font-size: 13px; color: #0d47a1; margin-top: 4px; font-weight: bold;">üéØ Import√¢ncia: ${(object.importance * 100).toFixed(0)}%</div>
                                </div>
                            </div>
                        `
                    };
                }
                
                if (layer.id === 'species-icons') {
                    return {
                        html: `
                            <div style="
                                background: rgba(255, 255, 255, 0.98); 
                                color: #000000; 
                                padding: 12px; 
                                border-radius: 8px; 
                                font-size: 13px;
                                border: 3px solid #ff9800;
                                box-shadow: 0 4px 16px rgba(0,0,0,0.5);
                            ">
                                <strong style="color: #e65100; font-size: 15px;">üêü ${object.name}</strong><br>
                                <div style="background: #fff3e0; padding: 8px; border-radius: 4px; margin-top: 6px;">
                                    <div style="font-size: 12px; color: #bf360c; font-weight: bold;">üìç Esp√©cie: ${object.species}</div>
                                    <div style="font-size: 12px; color: #424242; margin-top: 2px;">üìä Tamanho: ${object.size}</div>
                                </div>
                            </div>
                        `
                    };
                }
                
                if (layer.id === 'risk-zones') {
                    return {
                        html: `
                            <div style="
                                background: rgba(255, 255, 255, 0.98); 
                                color: #000000; 
                                padding: 12px; 
                                border-radius: 8px; 
                                font-size: 13px;
                                border: 3px solid #f44336;
                                box-shadow: 0 4px 16px rgba(0,0,0,0.5);
                            ">
                                <strong style="color: #c62828; font-size: 15px;">‚ö†Ô∏è ${object.type}</strong><br>
                                <div style="background: #ffebee; padding: 8px; border-radius: 4px; margin-top: 6px;">
                                    <div style="font-size: 12px; color: #d32f2f; font-weight: bold;">üö® N√≠vel: ${object.riskLevel.toUpperCase()}</div>
                                    <div style="font-size: 11px; color: #424242; margin-top: 4px;">${object.description}</div>
                                </div>
                            </div>
                        `
                    };
                }
                
                if (layer.id.includes('zee')) {
                    const isAngola = layer.id.includes('angola');
                    const bgColor = isAngola ? '#e3f2fd' : '#f3e5f5';
                    const borderColor = isAngola ? '#1976d2' : '#7b1fa2';
                    const textColor = isAngola ? '#0d47a1' : '#4a148c';
                    
                    return {
                        html: `
                            <div style="
                                background: rgba(255, 255, 255, 0.98); 
                                color: #000000; 
                                padding: 12px; 
                                border-radius: 8px; 
                                font-size: 13px;
                                border: 3px solid ${borderColor};
                                box-shadow: 0 4px 16px rgba(0,0,0,0.5);
                            ">
                                <strong style="color: ${textColor}; font-size: 14px; text-shadow: none;">üåä ZEE ${isAngola ? 'Angola Continental' : 'Cabinda'}</strong><br>
                                <div style="margin-top: 8px; font-size: 12px; color: #424242; background: ${bgColor}; padding: 8px; border-radius: 4px; font-weight: 600;">
                                    üìè √Årea: ${isAngola ? '495.866 km¬≤' : 'Prov√≠ncia separada'}<br>
                                    üèõÔ∏è Status: Oficial UNCLOS<br>
                                    üìä Fonte: Marine Regions
                                </div>
                            </div>
                        `
                    };
                }
                
                // Default tooltip for other elements
                return {
                    html: `
                        <div style="
                            background: rgba(255, 255, 255, 0.98); 
                            color: #000000; 
                            padding: 10px; 
                            border-radius: 6px; 
                            font-size: 13px;
                            border: 2px solid #00d4ff;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
                            font-weight: 600;
                            text-shadow: none;
                        ">
                            ${object.name || object.species || object.type || 'Elemento do mapa'}
                        </div>
                    `
                };
            }
            
            handleClick(object, layer) {
                this.log(`üéØ Click: ${object.name || object.type || 'objeto'}`);
                
                if (layer.id === 'copernicus-stations') {
                    alert(`üõ∞Ô∏è ${object.name}
                    
Temperatura: ${object.temp}¬∞C
Clorofila: ${object.chl} mg/m¬≥
Salinidade: ${object.salinity} PSU

${object.conditions}`);
                }
            }
            
            setLayers(layers) {
                if (this.deck) {
                    this.deck.setProps({layers});
                    this.layers = layers;
                }
            }
            
            addLayer(layer) {
                const newLayers = [...this.layers, layer];
                this.setLayers(newLayers);
                this.log(`‚úÖ Layer adicionada: ${layer.id}`);
            }
            
            removeLayer(layerId) {
                const filteredLayers = this.layers.filter(layer => layer.id !== layerId);
                this.setLayers(filteredLayers);
                this.log(`üóëÔ∏è Layer removida: ${layerId}`);
            }
            
            clearMLLayers() {
                // Keep only background + base layers
                const cleanLayers = [
                    this.currentBackground,
                    ...this.baseLayers
                ];
                this.setLayers(cleanLayers);
                this.log('üßπ Layers ML limpas');
            }
            
            switchBackground(backgroundType) {
                if (!this.backgroundLayers[backgroundType]) {
                    this.log(`‚ùå Background ${backgroundType} n√£o encontrado`);
                    return;
                }
                
                this.log(`üîÑ Mudando background para: ${backgroundType}`);
                
                this.currentBackground = this.backgroundLayers[backgroundType];
                
                // Rebuild layers with new background
                const nonBackgroundLayers = this.layers.filter(layer => 
                    !Object.values(this.backgroundLayers).includes(layer)
                );
                
                this.setLayers([
                    this.currentBackground,
                    ...nonBackgroundLayers
                ]);
                
                // Update UI
                document.querySelectorAll('[onclick^="switchBackground"]').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[onclick="switchBackground('${backgroundType}')"]`)?.classList.add('active');
                
                this.log(`‚úÖ Background mudado para: ${backgroundType}`);
            }
            
            // === ANIMATED VISUALIZATIONS ===
            
            startAnimationLoop() {
                const animate = () => {
                    this.time += 0.016;
                    this.updateAnimatedLayers();
                    this.animationId = requestAnimationFrame(animate);
                };
                this.animationId = requestAnimationFrame(animate);
            }
            
            updateAnimatedLayers() {
                // Update animated heatmap opacity
                const heatmapLayer = this.layers.find(layer => layer.id === 'animated-heatmap');
                if (heatmapLayer) {
                    const pulse = Math.sin(this.time * 2) * 0.2 + 0.8; // 0.6 to 1.0
                    const updatedLayer = heatmapLayer.clone({opacity: pulse});
                    
                    const layerIndex = this.layers.findIndex(layer => layer.id === 'animated-heatmap');
                    if (layerIndex >= 0) {
                        const newLayers = [...this.layers];
                        newLayers[layerIndex] = updatedLayer;
                        this.setLayers(newLayers);
                    }
                }
            }
            
            createAnimatedHeatmap() {
                this.log('üî• Criando heatmap ANIMADO...');
                
                this.removeLayer('animated-heatmap');
                
                const heatmapData = [
                    // Benguela Upwelling (alta biodiversidade)
                    {longitude: 13.4, latitude: -12.6, weight: 0.95},
                    {longitude: 13.2, latitude: -12.8, weight: 0.90},
                    {longitude: 13.0, latitude: -13.0, weight: 0.85},
                    
                    // Namibe Upwelling
                    {longitude: 12.1, latitude: -15.2, weight: 0.88},
                    {longitude: 11.9, latitude: -15.4, weight: 0.82},
                    
                    // Angola Current
                    {longitude: 13.2, latitude: -8.8, weight: 0.65},
                    {longitude: 12.8, latitude: -9.5, weight: 0.60},
                    
                    // Offshore (baixa biodiversidade)
                    {longitude: 10.5, latitude: -10.0, weight: 0.35},
                    {longitude: 9.5, latitude: -12.0, weight: 0.30},
                    {longitude: 8.5, latitude: -14.0, weight: 0.25}
                ];
                
                const heatmapLayer = new deck.HeatmapLayer({
                    id: 'animated-heatmap',
                    data: heatmapData,
                    getPosition: d => [d.longitude, d.latitude],
                    getWeight: d => d.weight,
                    radiusPixels: 100,
                    opacity: 0.8,
                    colorRange: [
                        [0, 0, 255, 50],      // Blue - Low
                        [0, 255, 255, 100],   // Cyan
                        [0, 255, 0, 150],     // Green
                        [255, 255, 0, 200],   // Yellow
                        [255, 165, 0, 230],   // Orange
                        [255, 0, 0, 255]      // Red - High
                    ]
                });
                
                this.addLayer(heatmapLayer);
                this.log(`‚úÖ Heatmap animado criado: ${heatmapData.length} hotspots`);
            }
            
            createSpeciesEmojis() {
                this.log('üêü Criando esp√©cies com √çCONES VISUAIS...');
                
                this.removeLayer('species-icons');
                
                const speciesData = [
                    {longitude: 13.0, latitude: -8.5, species: 'fish', name: 'Sardinha', size: 12, color: [0, 170, 255, 255]},
                    {longitude: 12.5, latitude: -12.0, species: 'whale', name: 'Baleia Jubarte', size: 18, color: [0, 102, 204, 255]},
                    {longitude: 13.2, latitude: -10.0, species: 'dolphin', name: 'Golfinho', size: 15, color: [0, 153, 255, 255]},
                    {longitude: 12.8, latitude: -14.0, species: 'turtle', name: 'Tartaruga', size: 14, color: [0, 204, 102, 255]},
                    {longitude: 11.5, latitude: -11.0, species: 'shark', name: 'Tubar√£o', size: 16, color: [255, 50, 50, 255]},
                    {longitude: 10.8, latitude: -13.5, species: 'octopus', name: 'Polvo', size: 12, color: [150, 0, 255, 255]},
                    {longitude: 12.2, latitude: -15.8, species: 'crab', name: 'Caranguejo', size: 10, color: [255, 165, 0, 255]},
                    {longitude: 11.0, latitude: -9.5, species: 'jellyfish', name: '√Ågua-viva', size: 13, color: [255, 105, 180, 255]}
                ];
                
                const speciesLayer = new deck.ScatterplotLayer({
                    id: 'species-icons',
                    data: speciesData,
                    pickable: true,
                    opacity: 0.9,
                    stroked: true,
                    filled: true,
                    radiusScale: 1,
                    radiusMinPixels: 8,
                    radiusMaxPixels: 25,
                    getPosition: d => [d.longitude, d.latitude],
                    getRadius: d => d.size,
                    getFillColor: d => d.color,
                    getLineColor: [255, 255, 255, 255],
                    lineWidthMinPixels: 3
                });
                
                this.addLayer(speciesLayer);
                this.log(`‚úÖ Esp√©cies com √≠cones visuais criadas: ${speciesData.length} esp√©cies`);
            }
            
            createRiskZones() {
                this.log('‚ö†Ô∏è Criando zonas de RISCO...');
                
                this.removeLayer('risk-zones');
                
                const riskZonesData = [
                    // Zona de polui√ß√£o pr√≥xima a Luanda
                    {
                        polygon: [
                            [13.0, -8.5], [13.5, -8.5], [13.5, -9.2], [13.0, -9.2], [13.0, -8.5]
                        ],
                        riskLevel: 'high',
                        type: 'Polui√ß√£o Urbana',
                        description: '√Årea de alto risco pr√≥xima ao porto de Luanda'
                    },
                    
                    // Zona de sobrepesca em Benguela
                    {
                        polygon: [
                            [12.8, -12.2], [13.6, -12.2], [13.6, -13.2], [12.8, -13.2], [12.8, -12.2]
                        ],
                        riskLevel: 'medium',
                        type: 'Sobrepesca',
                        description: '√Årea de pesca intensiva - monitoramento necess√°rio'
                    },
                    
                    // Zona de tr√°fego mar√≠timo
                    {
                        polygon: [
                            [10.5, -10.5], [11.5, -10.5], [11.5, -11.5], [10.5, -11.5], [10.5, -10.5]
                        ],
                        riskLevel: 'low',
                        type: 'Tr√°fego Mar√≠timo',
                        description: 'Rota de navega√ß√£o comercial'
                    },
                    
                    // Zona de explora√ß√£o offshore
                    {
                        polygon: [
                            [9.0, -13.0], [10.0, -13.0], [10.0, -14.5], [9.0, -14.5], [9.0, -13.0]
                        ],
                        riskLevel: 'medium',
                        type: 'Explora√ß√£o Offshore',
                        description: '√Årea de explora√ß√£o petrol√≠fera'
                    }
                ];
                
                const riskLayer = new deck.SolidPolygonLayer({
                    id: 'risk-zones',
                    data: riskZonesData,
                    filled: true,
                    stroked: true,
                    getFillColor: d => this.getRiskColor(d.riskLevel),
                    getLineColor: d => this.getRiskBorderColor(d.riskLevel),
                    lineWidthMinPixels: 3,
                    pickable: true,
                    opacity: 0.7
                });
                
                this.addLayer(riskLayer);
                this.log(`‚úÖ Zonas de risco criadas: ${riskZonesData.length} zonas`);
            }
            
            getRiskColor(riskLevel) {
                const colors = {
                    'high': [255, 0, 0, 100],     // Red transparent
                    'medium': [255, 165, 0, 80],  // Orange transparent
                    'low': [255, 255, 0, 60]      // Yellow transparent
                };
                return colors[riskLevel] || [128, 128, 128, 50];
            }
            
            getRiskBorderColor(riskLevel) {
                const colors = {
                    'high': [255, 0, 0, 255],     // Red solid
                    'medium': [255, 165, 0, 255], // Orange solid
                    'low': [255, 255, 0, 255]     // Yellow solid
                };
                return colors[riskLevel] || [128, 128, 128, 255];
            }
            
            createMigrationRoutes() {
                this.log('üêã Criando rotas de migra√ß√£o MELHORADAS...');
                
                this.removeLayer('migration-routes');
                this.removeLayer('migration-arrows');
                this.removeLayer('migration-labels');
                
                // Generate curved, natural migration paths
                const migrationPaths = this.generateNaturalMigrationPaths();
                
                // 1. Create curved migration paths using PathLayer
                const pathLayer = new deck.PathLayer({
                    id: 'migration-routes',
                    data: migrationPaths,
                    pickable: true,
                    widthScale: 1,
                    widthMinPixels: 6,
                    widthMaxPixels: 25,
                    getPath: d => d.path,
                    getColor: d => d.color,
                    getWidth: d => d.width,
                    capRounded: true,
                    jointRounded: true,
                    billboard: false
                });
                
                // 2. Add animated flow dots along paths
                const flowDots = this.generateFlowDots(migrationPaths);
                const flowLayer = new deck.ScatterplotLayer({
                    id: 'migration-flow',
                    data: flowDots,
                    pickable: false,
                    opacity: 0.8,
                    stroked: false,
                    filled: true,
                    radiusScale: 1,
                    radiusMinPixels: 4,
                    radiusMaxPixels: 8,
                    getPosition: d => [d.longitude, d.latitude],
                    getRadius: 6,
                    getFillColor: d => [...d.color, 200]
                });
                
                // 3. Species emoji markers at key points
                const speciesMarkers = migrationPaths.map(path => ({
                    longitude: path.path[0][0], // Start point
                    latitude: path.path[0][1],
                    emoji: this.getSpeciesEmoji(path.species),
                    species: path.species,
                    season: path.season
                }));
                
                const markersLayer = new deck.TextLayer({
                    id: 'migration-markers',
                    data: speciesMarkers,
                    pickable: true,
                    getPosition: d => [d.longitude, d.latitude],
                    getText: d => d.emoji,
                    getSize: 28,
                    getColor: [255, 255, 255, 255],
                    getAngle: 0,
                    getTextAnchor: 'middle',
                    getAlignmentBaseline: 'center',
                    fontFamily: 'Arial, sans-serif',
                    background: true,
                    getBackgroundColor: [0, 0, 0, 150],
                    backgroundPadding: [4, 2]
                });
                
                // 4. Route information labels
                const infoLabels = migrationPaths.map(path => {
                    const midPoint = Math.floor(path.path.length / 2);
                    return {
                        longitude: path.path[midPoint][0] + 0.3,
                        latitude: path.path[midPoint][1],
                        text: `${path.species}\n${path.season}`,
                        color: path.color
                    };
                });
                
                const infoLayer = new deck.TextLayer({
                    id: 'migration-info',
                    data: infoLabels,
                    pickable: true,
                    getPosition: d => [d.longitude, d.latitude],
                    getText: d => d.text,
                    getSize: 12,
                    getColor: [255, 255, 255, 255],
                    getAngle: 0,
                    getTextAnchor: 'start',
                    getAlignmentBaseline: 'center',
                    fontFamily: 'Arial, sans-serif',
                    fontWeight: 'bold',
                    background: true,
                    getBackgroundColor: [0, 0, 0, 200],
                    backgroundPadding: [3, 2]
                });
                
                this.addLayer(pathLayer);
                this.addLayer(flowLayer);
                this.addLayer(markersLayer);
                this.addLayer(infoLayer);
                
                this.log(`‚úÖ Rotas ILUSTRATIVAS criadas: ${migrationPaths.length} rotas curvas + ${flowDots.length} dots + emojis`);
            }
            
            generateNaturalMigrationPaths() {
                // Create curved, natural migration paths
                const paths = [
                    // Baleia Jubarte - Rota costeira curva (norte-sul)
                    {
                        species: 'Baleia Jubarte',
                        path: [
                            [12.0, -6.0],   // Start: Norte
                            [12.2, -8.0],   // Curva 1
                            [12.5, -10.0],  // Curva 2
                            [12.3, -12.0],  // Curva 3
                            [12.0, -14.0],  // Curva 4
                            [11.5, -16.0]   // End: Sul
                        ],
                        width: 12,
                        color: [0, 150, 255, 255],
                        season: 'Jun-Set'
                    },
                    
                    // Sardinha - Rota costeira seguindo upwelling
                    {
                        species: 'Sardinha',
                        path: [
                            [13.5, -10.0],  // Start: Norte costeiro
                            [13.4, -11.0],  // Acompanha costa
                            [13.3, -12.0],  // Benguela area
                            [13.1, -13.0],  // Curva upwelling
                            [12.8, -14.0]   // End: Zona upwelling
                        ],
                        width: 15,
                        color: [0, 255, 150, 255],
                        season: 'Mar-Jun'
                    },
                    
                    // Atum - Rota oce√¢nica profunda (curva ampla)
                    {
                        species: 'Atum',
                        path: [
                            [9.0, -7.0],    // Start: Offshore norte
                            [9.5, -9.0],    // Curva oce√¢nica
                            [10.0, -11.0],  // Curva central
                            [10.2, -13.0],  // Curva sul
                            [10.5, -15.0],  // Curva profunda
                            [10.5, -17.0]   // End: Offshore sul
                        ],
                        width: 10,
                        color: [255, 100, 0, 255],
                        season: 'Todo ano'
                    },
                    
                    // Baleia Azul - Rota oce√¢nica profunda
                    {
                        species: 'Baleia Azul',
                        path: [
                            [10.0, -8.0],   // Start: Offshore
                            [9.8, -10.0],   // Curva oce√¢nica
                            [9.6, -12.0],   // √Åguas profundas
                            [9.5, -15.0]    // End: Sul profundo
                        ],
                        width: 8,
                        color: [0, 100, 200, 240],
                        season: 'Jul-Ago'
                    },
                    
                    // Tartaruga - Rota reprodutiva (costa para offshore)
                    {
                        species: 'Tartaruga Marinha',
                        path: [
                            [13.0, -9.0],   // Start: Costa (nidifica√ß√£o)
                            [12.5, -10.0],  // Sa√≠da da costa
                            [11.5, -11.0],  // Curva offshore
                            [10.5, -11.5],  // √Åguas de alimenta√ß√£o
                            [10.0, -12.0]   // End: Offshore
                        ],
                        width: 6,
                        color: [100, 255, 100, 220],
                        season: 'Nov-Jan'
                    }
                ];
                
                return paths;
            }
            
            generateFlowDots(migrationPaths) {
                const dots = [];
                
                migrationPaths.forEach(path => {
                    // Create animated dots along each path
                    const numDots = 8;
                    
                    for (let i = 0; i < numDots; i++) {
                        const progress = i / numDots;
                        const pathIndex = Math.floor(progress * (path.path.length - 1));
                        const nextIndex = Math.min(pathIndex + 1, path.path.length - 1);
                        
                        // Interpolate position along path
                        const localProgress = (progress * (path.path.length - 1)) - pathIndex;
                        const lon = path.path[pathIndex][0] + 
                                   (path.path[nextIndex][0] - path.path[pathIndex][0]) * localProgress;
                        const lat = path.path[pathIndex][1] + 
                                   (path.path[nextIndex][1] - path.path[pathIndex][1]) * localProgress;
                        
                        dots.push({
                            longitude: lon,
                            latitude: lat,
                            color: path.color.slice(0, 3), // RGB without alpha
                            species: path.species,
                            dotIndex: i
                        });
                    }
                });
                
                return dots;
            }
            
            getSpeciesEmoji(species) {
                const emojis = {
                    'Baleia Jubarte': 'üêã',
                    'Baleia Azul': 'üê≥', 
                    'Sardinha': 'üêü',
                    'Atum': 'üê†',
                    'Tartaruga Marinha': 'üê¢'
                };
                return emojis[species] || 'üêü';
            }
            
            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.textContent = `[${timestamp}] ${message}`;
                this.logContainer.appendChild(logEntry);
                this.logContainer.scrollTop = this.logContainer.scrollHeight;
                
                // Keep only last 15 entries
                while (this.logContainer.children.length > 15) {
                    this.logContainer.removeChild(this.logContainer.children[0]);
                }
            }
        }
        
        // Global instance
        let deckglDemo;
        
        // Global functions
        function confirmDeckGL() {
            if (!deckglDemo || !deckglDemo.deck) {
                alert('‚ùå deck.gl n√£o dispon√≠vel');
                return;
            }
            
            const layers = deckglDemo.layers.length;
            
            deckglDemo.log('üîç CONFIRMA√á√ÉO deck.gl WebGL2');
            
            alert(`üîç CONFIRMA√á√ÉO DECK.GL:
            
‚úÖ Framework: deck.gl WebGL2
üìä Layers ativas: ${layers}
üåä ZEE: Delimita√ß√µes oficiais Angola
üõ∞Ô∏è Copernicus: 5 esta√ß√µes reais
üó∫Ô∏è Background: EOX Terrain + Bathymetry

‚úÖ deck.gl CONFIRMADO!`);
        }
        
        function debugZEELayers() {
            if (!deckglDemo) {
                alert('‚ùå deckglDemo n√£o dispon√≠vel');
                return;
            }
            
            deckglDemo.log('üîç === DEBUG ZEE LAYERS ===');
            
            const layers = deckglDemo.layers;
            const layerInfo = layers.map(layer => `${layer.id}: ${layer.constructor.name}`).join('\n');
            
            deckglDemo.log(`üìä Total layers: ${layers.length}`);
            layers.forEach((layer, index) => {
                deckglDemo.log(`   ${index + 1}. ${layer.id} (${layer.constructor.name})`);
                if (layer.id.includes('zee')) {
                    const data = layer.props.data;
                    if (data && data[0] && data[0].polygon) {
                        deckglDemo.log(`      Pontos: ${data[0].polygon.length}`);
                        deckglDemo.log(`      Primeiro: [${data[0].polygon[0][0]}, ${data[0].polygon[0][1]}]`);
                    }
                }
            });
            
            alert(`üîç DEBUG ZEE LAYERS:

üìä Total layers: ${layers.length}

${layerInfo}

Verifique o log para detalhes das coordenadas!`);
        }
        
        function createAnimatedHeatmap() {
            if (deckglDemo) {
                deckglDemo.createAnimatedHeatmap();
            }
        }
        
        function createSpeciesEmojis() {
            if (deckglDemo) {
                deckglDemo.createSpeciesEmojis();
            }
        }
        
        function createMigrationRoutes() {
            if (deckglDemo) {
                deckglDemo.createMigrationRoutes();
            }
        }
        
        function createRiskZones() {
            if (deckglDemo) {
                deckglDemo.createRiskZones();
            }
        }
        
        function createAllVisualizations() {
            if (deckglDemo) {
                deckglDemo.log('üé® Criando TODAS as visualiza√ß√µes...');
                deckglDemo.createAnimatedHeatmap();
                setTimeout(() => deckglDemo.createSpeciesEmojis(), 500);
                setTimeout(() => deckglDemo.createMigrationRoutes(), 1000);
                setTimeout(() => deckglDemo.createRiskZones(), 1500);
                setTimeout(() => deckglDemo.log('‚úÖ Todas as visualiza√ß√µes criadas!'), 2000);
            }
        }
        
        function clearAllLayers() {
            if (deckglDemo) {
                deckglDemo.clearMLLayers();
            }
        }
        
        function switchBackground(backgroundType) {
            if (deckglDemo) {
                deckglDemo.switchBackground(backgroundType);
            }
        }
        
        function resetView() {
            if (deckglDemo && deckglDemo.deck) {
                deckglDemo.deck.setProps({
                    initialViewState: {
                        longitude: 13.5,
                        latitude: -12.5,
                        zoom: 6,
                        pitch: 0,
                        bearing: 0,
                        transitionDuration: 1000
                    }
                });
                deckglDemo.log('üéØ Vista resetada para Angola');
            }
        }
        
        function takeScreenshot() {
            if (deckglDemo) {
                const canvas = document.querySelector('#deckgl-map canvas');
                if (canvas) {
                    const link = document.createElement('a');
                    link.download = `angola-deckgl-${Date.now()}.png`;
                    link.href = canvas.toDataURL();
                    link.click();
                    deckglDemo.log('üì∏ Screenshot salvo');
                }
            }
        }
        
        function toggleFullscreen() {
            const container = document.getElementById('deckgl-map');
            if (!document.fullscreenElement) {
                container.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            deckglDemo = new DeckGLMLDemoFinal();
        });
    </script>
</body>
</html>
